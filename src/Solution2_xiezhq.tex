\documentclass[10pt]{article}
\usepackage[pdftex]{graphicx, color}
\usepackage{listings}
\usepackage{amsmath}
\usepackage[]{forest}
\forestset{.style={for tree={parent anchor=south, child anchor=north,align=center,inner sep=2pt}}}
\usepackage{tikz}
\usepackage{multirow}

\usetikzlibrary{automata,positioning}

\headheight 8pt \headsep 20pt \footskip 30pt
\textheight 9in \textwidth 6.5in
\oddsidemargin 0in \evensidemargin 0in
\topmargin -.35in

\lstset{basicstyle=\small\ttfamily,breaklines=true}
\newcommand {\pts}[1]{{\bf #1 pts}}

\begin{document}
\begin{center}
\Large CS131 Compilers: Writing Assignment 2\\Due Sunday, April 15, 2018 at 23:29
\end{center}

\begin{center}
%% Change this:
\LARGE Zhiqiang Xie - 77892769
\end{center}

This assignment asks you to prepare written answers to questions on
context-free grammars and parsing. Each of the questions has a short answer. You
may discuss this assignment with other students and work on the problems
together. However, your write-up should be your own individual work.
and you should indicate in your submission who you worked with, if applicable.
You should use the Latex template provided at the course web site to write your solution.

\begin{center}
%% Change this:
I worked with: (Li Dinghong, 27663262), (Name,ID)...
\end{center}

\begin{enumerate}

\item  \pts{$2\times 3= 6$} Give context-free grammar (CFG) for each of the following languages:
    \begin{enumerate}
           \item The set of all finite strings over the alphabet $\{0,1\}$ with an equal number of 0's and 1's.
            \[
            S \rightarrow 0\ S\ 1\ S\ |\ 1\ S\ 0\ S\ |\  \epsilon
            \]
           \item The set of all finite strings over the alphabet $\{0,1\}$ with the number of 0's greater than the number of 1's.
           \begin{align*}
               S       &\rightarrow equal\ 0\ equal\ |\  equal\ 0\ S\\
               equal   &\rightarrow 0\ equal\ 1\ equal\
                        |\ 1\ equal\ 0\ equal\
                        |\ \epsilon
           \end{align*}
           \item The set $L_3=L_1\cap L_2$, where $L_1$ and $L_2$ are defined below.
           Let $L_1$ be the finite strings consisting of all non-empty \emph{palindromes} over the alphabet $\{a,b\}$. That is $L_1$
           consists of all sequences of a's and b's that read the same forward or backward. For example, $abba,~aabbbaa\in L_1$, but $abb\not\in L_1$.
           Let $L_2$ be the language over  $\{a,b\}$ representing the language of the regular expression $b(a+b)^\ast$.
           \begin{align*}
               S    &\rightarrow b\ P\ b \\
               P    &\rightarrow a\ P\ a\ |\ b\ P\ b\ |\ \epsilon
           \end{align*}
    \end{enumerate}

\newpage

\item \pts{$3\times 2= 6$} Consider the following CFG with terminals $\{(,),+,*,a,b\}$ ($+$ represents union) that is used to represent
regular expressions over alphabet $\{a, b\}$:
\[R\rightarrow R+R \mid RR\mid (R)\mid R^\ast \mid a\mid b\]

    \begin{enumerate}
      \item Using the above CFG, provide a right-most derivation for the following input string $(a+(ba)^\ast b)^\ast$.
                \begin{align*}
                    R &\Rightarrow R^* \Rightarrow (R)^* \\
                      &\Rightarrow (R+R)^*\\
                      &\Rightarrow (R+RR)^*\Rightarrow (R+Rb)^* \Rightarrow (R+R^*b)^*\Rightarrow (R+(R)^*b)^* \\
                      &\Rightarrow (R+(RR)^*b)^*\Rightarrow (R+(Ra)^*b)^*\Rightarrow (R+(ba)^*b)^*\Rightarrow (a+(ba)^*b)^*
                \end{align*}
      \item For the derivation in above solution, provide the corresponding parse tree.
      \\

      \centering
      \begin{forest}
            [R
                [R
                    [(]
                    [R
                        [R [a]]
                        [+]
                        [R
                            [R
                                [R
                                    [(]
                                    [R
                                        [R [b]]
                                        [R [a]]
                                    ]
                                    [)]
                                ]
                                [*]
                            ]
                            [R [b]]
                        ]
                    ]
                    [)]
                ]
                [*]
            ]
        \end{forest}
    \end{enumerate}

\newpage

\item \pts{$3\times 3= 9$} Consider the following CFG.
\[\begin{array}{cll}
S & \rightarrow & AED \mid F \\
A & \rightarrow & Aa \mid a \\
B & \rightarrow & Bb \mid b \\
C & \rightarrow & Cc \mid c \\
D & \rightarrow & Dd \mid d \\
E & \rightarrow & bEc \mid bc \\
F & \rightarrow & aFd \mid BC
\end{array}\]

\begin{enumerate}
\item What is the language generated by this grammar?
            \[
            L = \{a^ib^jc^jd^k, a^ib^jc^kd^i \ | \ i,j,k\geq 1\}
            \]
\item Is the grammar as given ambiguous? If yes, give an example of an expression
with two parse trees under this grammar. If not, explain why that is the case.
\\\\
It's ambiguous, because a string can both have the two features for parsing,
which are the number of $b$ is equal to the number of $c$, the number of $a$ is equal to $d$.
For example $abcd$:\\
\begin{forest}
    [S
        [A [a]]
        [E [b] [c]]
        [D [d]]
    ]
\end{forest}
\begin{forest}
    [S
        [F
            [a]
            [F
                [B [b]]
                [C [c]]
            ]
            [d]
        ]
    ]
\end{forest}
\item Transform the CFG given above by eliminating ambiguity and left recursion, if needed.\\\\
    The main idea is to make $AED$ and $F$ disjoint:
    \[\begin{array}{cll}
    S & \rightarrow & AED \mid F \\
    A & \rightarrow & a \mid aA \\
    B & \rightarrow & b \mid bB \\
    C & \rightarrow & c \mid cC \\
    D & \rightarrow & d \mid dD \\
    E & \rightarrow & bEc \mid bc \\
    F & \rightarrow & aFd \mid BE \mid EC
    \end{array}\]
\end{enumerate}


\newpage
\item \pts{$3\times 3= 9$} Consider the following CFG.
\[\begin{array}{cll}
A & \rightarrow & [AB] \mid a \\
B & \rightarrow & \epsilon \mid +AC \mid Cb \\
C & \rightarrow & \epsilon \mid -ABc
\end{array}\]

\begin{enumerate}
    \item Compute the First and Follow sets for the grammar.
        \begin{align*}
            FIRST([AB])     &= \{[\}                \\
            FIRST(a)        &= \{a\}                \\
            FIRST(A)        &= \{[, a\}             \\
            FIRST(\epsilon) &= \{\epsilon\}         \\
            FIRST(+AC)      &= \{+\}                \\
            FIRST(-ABc)     &= \{-\}                \\
            FIRST(C)        &= \{\epsilon, -\}      \\
            FIRST(Cb)       &= \{b, -\}             \\
            FIRST(B)        &= \{\epsilon, +, -, b\}\\
            \\
            FOLLOW(B)       &= \{],c\}              \\
            FOLLOW(C)       &= \{b,],c\}            \\
            FOLLOW(A)       &= \{\$,+,-,b,c,]\}
        \end{align*}
    \item Give the LL(1) parsing table for the grammar.\\
    \begin{table}[h!]
    \centering
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|}
            \hline
            \multirow{2}{6em}{NON-TERMINAL}
                                & \multicolumn{8}{|c|}{Input} \\
            \cline{2-9}         & [ & ] & a & b & c & + & - & \$ \\ \hline
            A                   & $A \rightarrow [AB]$ & & $A \rightarrow a$ & &  &  &  &\\ \hline
            B                   & & $B \rightarrow \epsilon$ & & $B\rightarrow Cb $ & $B \rightarrow \epsilon$ & $B \rightarrow +AC$ & $B \rightarrow Cb$ &\\ \hline
            C                  &  & $C \rightarrow \epsilon$ &  & $C \rightarrow \epsilon$ & $C \rightarrow \epsilon$ &  & $C \rightarrow -ABc$ & \\ \hline
        \end{tabular}
        \caption{LL(1) parsing table}
    \end{table}
    \item Is this grammar LL(1)? and Why.
        \\
        Yes, it is LL(1) grammar, which satisfies: \\
            For any two distinct productions $A \rightarrow \alpha | \beta$, \\
            For no terminal $a$ do both $\alpha$ and $\beta$ derive strings beginning with $a$.\\
            At most one of $\alpha$ and $\beta$ can derive the empty string.\\
            If $\beta \overset{*}{\Rightarrow} \epsilon$, then $\alpha$
            does not derive any string beginning with a terminal in $FOLLOW(A)$.
            Likewise, if $\alpha \overset{*}{\Rightarrow} \epsilon$, then $\beta$
            does not derive any string beginning with a terminal in $FOLLOW(A)$.

\end{enumerate}

\newpage

\item \pts{$8$}  Using the context-free grammar for Cool given in Section 11 of the Cool
manual, draw a parse tree for the following expression.
  \begin{lstlisting}
    while not (x <-z <- 0) loop
      y <- z + 2 * x + 1
    pool
  \end{lstlisting}
Note that the context-free grammar by itself is ambiguous, so you will
need to use the precedence and associativity rules in Section 11.1 to
get the correct tree.\\

\centering
\begin{forest}
    [expr
        [\textbf{while}]
        [expr
            [\textbf{not}]
            [expr
                [(]
                [expr
                    [\textbf{ID} [x]]
                    [$\leftarrow$]
                    [expr
                        [\textbf{ID} [z]]
                        [$\leftarrow$]
                        [expr
                            [\textbf{integer} [0]]
                        ]
                    ]
                ]
                [)]
            ]
        ]
        [\textbf{loop}]
        [expr
            [\textbf{ID} [y]]
            [$\leftarrow$]
            [expr
                [expr
                    [expr
                        [\textbf{ID} [z]]
                    ]
                    [+]
                    [expr
                        [expr
                            [\textbf{integer} [2]]
                        ]
                        [*]
                        [expr
                            [\textbf{ID} [x]]
                        ]
                    ]
                ]
                [+]
                [expr
                    [\textbf{integer} [1]]
                ]
            ]
        ]
        [\textbf{pool}]
    ]
\end{forest}

\newpage
\item \pts{$4\times 4 =16$} Consider the following grammar describing a certain sort of nested lists:
\[\begin{array}{cll}
S & \rightarrow & T;S \mid \epsilon \\
T & \rightarrow & U\star T \mid U \\
U & \rightarrow & x\mid y\mid [S]
\end{array}\]
$S$, $T$, and $U$ are nonterminals, while others are terminals.
\begin{enumerate}
    \item Left-factor this grammar.
        \begin{align*}
            S   &\rightarrow T;S \mid \epsilon      \\
            T   &\rightarrow UT'                    \\
            T'  &\rightarrow \star T \mid \epsilon  \\
            U   &\rightarrow x\mid y\mid [S]
        \end{align*}
    \item Give the First and Follow sets for each nonterminal in the grammar obtained in part (a).
        \begin{align*}
            FIRST(U)    &= \{x, y, [\}          \\
            FIRST(T)    &= \{x, y, [\}          \\
            FIRST(S)    &= \{x, y, [, \epsilon\}\\
            FIRST(T')   &= \{\star, \epsilon\}  \\
            \\
            FOLLOW(S)   &= \{\$, ]\}    \\
            FOLLOW(T)   &= \{;\}        \\
            FOLLOW(T')  &= \{;\}        \\
            FOLLOW(U)   &= \{;, \star\}  \\
        \end{align*}
    \item Using this information, construct an LL(1) parsing table for the grammar obtained in part (a).
    \begin{table}[h!]
    \centering
      \begin{tabular}{|c|c|c|c|c|c|c|c|}
          \hline
          \multirow{2}{6em}{NON-TERMINAL}
                              & \multicolumn{7}{|c|}{Input} \\
          \cline{2-8}         & [ & ] & x & y & $\star$ & ; & \$  \\ \hline
          S                   & $S \rightarrow T;S$ & $S \rightarrow \epsilon$ & $S \rightarrow T;S$ & $S \rightarrow T;S$ &  &  & $S \rightarrow \epsilon$  \\ \hline
          T                   & $T \rightarrow UT'$ &  & $T \rightarrow UT'$ & $T \rightarrow UT'$ &  &  &  \\ \hline
          T'                  &  &  &  &  & $T' \rightarrow \star T$ & $T' \rightarrow \epsilon$ &  \\ \hline
          U                   & $U\rightarrow[S]$ &  & $U\rightarrow x$ & $U\rightarrow y$ &  &  &  \\ \hline
      \end{tabular}
      \caption{LL(1) parsing table}
    \end{table}
    \item Suppose we generated an LL(1) parser for the grammar using the table you constructed. What would go wrong if it tried to parse the following input string?
    \[[x;y]\star [;\]
    \\
    The error will occur at the time of inputting the last '$;$', which is in
    the state $S$ and the '$;$' is illegal.
\end{enumerate}

\newpage
\item \pts{$3\times 2+5\times 2 =16$} Consider the following CFG, which has the set of terminals
$T = \{ \textbf{a}, \textbf{b} \}$.
\[\begin{array}{cll}
 S & \rightarrow & X \textbf{a} \\
X & \rightarrow & \textbf{a} \mid \textbf{a} X \textbf{b}
\end{array}\]

\begin{enumerate}

\item Construct a DFA for viable prefixes of this grammar using LR(0)
items.
\begin{center}\begin{tikzpicture}[shorten >=1pt,node distance=5cm,on grid,auto]
    \node[state] (I0) {
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & I_0: \\
            & S' \rightarrow .S \\
            & S\rightarrow .Xa \\
            & X\rightarrow .a \\
            & X\rightarrow .aXb \\
        \end{aligned}\end{equation*}}
    };

    \node[state, right of=I0, node distance=5cm] (I2){
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & I_2: \\
            & S\rightarrow X.a \\
        \end{aligned}\end{equation*}}
    };
    \node[state, above of=I2, node distance=3.5cm] (I1) {
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & I_1: \\
            & S' \rightarrow S. \\
        \end{aligned}\end{equation*}}
    };

    \node[state, right of=I1, node distance=4cm,accepting] (acc){
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & accept \\
        \end{aligned}\end{equation*}}
    };
    \node[state, right of=I2, node distance=4cm] (I4){
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & I_4: \\
            & S\rightarrow Xa. \\
        \end{aligned}\end{equation*}}
    };
    \node[state, below of=I2, node distance=3.5cm] (I3){
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & I_3: \\
            & X\rightarrow a. \\
            & X\rightarrow a.Xb \\
            & X\rightarrow .aXb \\
        \end{aligned}\end{equation*}}
    };
    \node[state, right of=I3, node distance=4cm] (I5){
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & I_5: \\
            & X\rightarrow aX.b \\
        \end{aligned}\end{equation*}}
    };
    \node[state, right of=I5, node distance=4cm] (I6){
        \parbox{2cm}{\begin{equation*}\begin{aligned}
            & I_6: \\
            & X\rightarrow aXb. \\
        \end{aligned}\end{equation*}}
    };
    \path[->]
    (I0) 	edge 					node[above]{$X$} (I2)
            edge 	[bend right] 	node[below]{$a$} (I3)
            edge 	[bend left] 	node[above]{$S$} (I1)
    (I1) 	edge 				 	node[above]{$\$$} (acc)
    (I2) 	edge 					node[above]{$a$} (I4)
    (I3) 	edge 	[loop below] 	node[below]{$a$} ()
            edge 					node[below]{$X$} (I5)
    (I5) 	edge 					node[below]{$b$} (I6);

\end{tikzpicture}\end{center}
\item Identify a shift-reduce conflict in this grammar under the
SLR(1) rules.\\
\begin{table}[h]
\centering
\begin{tabular}{c|ccc|cc}
\hline
\multirow{2}{*}{State} & \multicolumn{3}{c|}{Actions} & \multicolumn{2}{c}{Goto} \\ \cline{2-6}
                  &  $a$  &  $b$  &  $\$$ &    $S$    &    $X$    \\ \hline
       0          &   s3  &       &       &     s1    &     s2    \\
       1          &       &       &  acc  &           &           \\
       2          &   s4  &       &       &           &           \\
       3          & \textbf{s3/r2} &   r2  &       &           &     s5    \\
       4          &       &       &   r1  &           &           \\
       5          &       &   s6  &       &           &           \\
       6          &   r3  &   r3  &       &           &           \\ \hline
\end{tabular}
\caption{Parsing table}
\end{table}
In the state $I_3$, we can either reduce $a$ to $X$ or keep shifting when $a$ is inputting.\\

\item Assuming that an SLR(1) parser resolves shift-reduce conflicts
by choosing to shift, show the operation of such a parser on the input
string \textbf{aaba}.
\begin{center}\begin{tabular}{l|r|l}
\textbf{Stack} & \textbf{Input} & \textbf{Action} \\
\$ & aaba\$ & shift \\
\$a & aba\$ & shift \\
\$aa & ba\$ & reduce by $X\rightarrow a$ \\
\$aX & ba\$ & shift \\
\$aXb & a\$ & reduce by $X\rightarrow aXb$ \\
\$X & a\$ & shift\\
\$Xa & \$ & reduce by $S\rightarrow Xa$ \\
\$S & \$ &  accept\\
\end{tabular}\end{center}
\item Suppose that the production $X \rightarrow \varepsilon$ is added
to this grammar.  Identify a reduce-reduce conflict in the resulting
grammar under the SLR(1) rules.\\
Still in the state $I_3$, we can either reduce $a$ to $X$ or applying $X\rightarrow \epsilon$\\

\end{enumerate}
\end{enumerate}
\end{document}
